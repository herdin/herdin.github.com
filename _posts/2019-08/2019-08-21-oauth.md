---
layout: post
title: "OAuth"
date: 2019-08-21
tags: web
---

`OAuth` 를 알아보기 전에 용어 정리가 필요하다.
- Authentication : 인증, `내맘대로 해석 - 요청 대상이 예상하는 대상이 맞는지 확인하는 것.`
> 컴퓨터 보안에서 인증은 로그인 요청 등을 통해 통신 상에서 보내는 사람의 디지털 정체성을 확인하는 시도의 과정이다. [출처](https://ko.wikipedia.org/wiki/%EC%9D%B8%EC%A6%9D#%EC%BB%B4%ED%93%A8%ED%84%B0_%EB%B3%B4%EC%95%88)

- Authorization : 허가, 인가, `내맘대로 해석- 요청 자원에 대한 접근 허가`
> 허가(허용; authorization)란 리소스에 대한 접근 권한 및 정책을 지정하는 기능이다. 정보 보안 및 컴퓨터 보안, 특히 접근 제어 분야와 관련이 있다.[1] 예를 들어 인사부서 직원들은 보통 직원 데이터를 열람할 수 있도록 허용되어 있는데, 이러한 정책은 일반적으로 컴퓨터 시스템에 접근 제어 규칙들로 저장된다. 컴퓨터 시스템은 어떤 (인증된) 리소스 수요자가 리소스에 대한 요청을 하면, 저장된 접근 제어 규칙들을 적용해 요청을 허가할지 거부할지를 결정한다. 여기서 리소스는 개개의 파일 또는 데이터, 컴퓨터 프로그램이나 프로그램의 일부 기능, 컴퓨터 하드웨어 및 장치 등을 포함한다. 그리고 리소스 수요자는 컴퓨터 사용자뿐만 아니라 컴퓨터 프로그램이나 다른 장치들이 될 수도 있다. [출처](https://ko.wikipedia.org/wiki/허가_(컴퓨터_과학))

## `OAuth 1.0a`

1.0 이 기존에 있었지만, 보안이 수정된 1.0 revision A 이 표준 `RFC5849` 로 등록이 되었다고하니 1.0 revision A 만 살짝 맛보고 가면 되겠다. 지금 사용하는건 대부분 2.0 이니까..

### 용어

<table class="pure-table">
<thead>
  <tr>
    <th>용어</th>
    <th>설명</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>User</td>
    <td>Service Provider 에 계정을 가지고 있으면서, Consumer 를 이용하려는 사용자</td>
  </tr>
  <tr>
    <td>Consumer</td>
    <td>OAuth 를 사용하는 Open API 를 제공하는 서비스</td>
  </tr>
  <tr>
    <td>Service Provider</td>
    <td>OAuth 인증을 사용해 Service Provider 의 기능을 사용하려는 애플리케이션이나 웹 서비스</td>
  </tr>
  <tr>
    <td>Request Token</td>
    <td>Consumer가 Service Provider 에게 접근 권한을 인증받기 위해 사용하는 값. 인증이 완료된 후에는 Access Token 으로 교환.</td>
  </tr>
  <tr>
    <td>Access Token</td>
    <td>인증 후 Consumer 가 Service Provider 의 자원에 접근하기 위한 키를 포함한 값</td>
  </tr>
</tbody>
</table>

### Flow
![OAuth1.0 flow](/assets/images/posts/2019-08-21-oauth-02.png)

`OAuth 2.0` 을 먼저 배웠고, 어떤 형태를 거쳐 여기까지 왔는지 궁금하여 검색해 본 것인데, `Flow` 를 대충 보고 참고자료를 보며 느낀 점은 `음? 별로 크게 다르지 않은 것 같네?` 였다. 웹애플리케이션이 아닌 일반 애플리케이션에 대한 지원강화, HTTPS 사용으로 보안알고리즘 사용 자제, `Access Token` 의 만료적용. 이 정도가 크게 달라진 점 같다. 아 그냥 이랬구나 하고 넘어가련다.

## `OAuth 2.0`

### 용어

<table class="pure-table">
<thead>
  <tr>
    <th>용어</th>
    <th>설명</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Client</td>
    <td>OAuth 인증을 사용해 Resource Server 의 Resource Owner 의 Resource 를 획득하려는 애플리케이션이나 웹 서비스 (ex: Facebook 에 공유 기능을 제공하는 앱)</td>
  </tr>
  <tr>
    <td>Resource Owner</td>
    <td>Resource 를 Resource Server 에 가지고 있으면서, Client 를 이용하려는 사용자 (ex: 일반사용자)</td>
  </tr>
  <tr>
    <td>Authoriztion Server</td>
    <td>Authentication (인증) 이 끝난 뒤, 어떤 자원에 접근할지 Authorization (인가) 해 주는 서버</td>
  </tr>
  <tr>
    <td>Resource Server</td>
    <td>Resource Owner 의 Resource 를 관리하는 서버</td>
  </tr>
</tbody>
</table>

![OAuth2.0 Flow](/assets/images/posts/2019-08-21-oauth-01.png)
> [from slack api doc](https://api.slack.com/docs/oauth)

`Flow` 를 보면 알 수 도 있지만, 간략하게 순서를 정리해 보자면 (`Web Application` 기준)

1. `OAuth 2.0` 의 방식으로 `API Service` 를 제공하는 서비스에 가입하여 본인이 개발할 `Web Application` 을 등록한다.
2. `Client ID`, `Client Secret` 을 발급 받고, 본인이 개발할 `Web Application` 의 `Callback URL` 을 등록한다.
3. `Access Token` 을 `OAuth 2.0 Flow` 에 따라서 발급받는 `Web Application` 기능을 추가한다.
4. `OAuth 2.0 Flow` 를 따라 `Web Application` 에서 `Acess Token` 을 발급 받는다.
5. `Acess Token` 으로 `Resource` 에 접근한다.

Naver, Facebook, Instagram, Google+ 등과 라이브러리 없이 연동을 해 보았다. 약간씩 파라미터가 다르지만 대동소이하다. 예제는 Naver.

### 설정 값을 저장할 `Constants` class.

``` java
package util;

import io.netty.handler.codec.http.HttpMethod;

public class Constants {
	public enum OAUTH2_CLIENT {
		NAVER(
			/* auth uri     */ "https://nid.naver.com/oauth2.0/authorize"
			/* auth method  */, HttpMethod.POST
			/* token uri    */, "https://nid.naver.com/oauth2.0/token"
			/* token method */, HttpMethod.POST
			/* resource uri           */, "https://openapi.naver.com/v1/nid/me"
			/* resource method        */, HttpMethod.POST
			/* resource header keys   */, new String[] {"Authorization"}
			/* resource header values */, new String[] {"Bearer "}
			/* client id     */, "MY_CLIENT_ID"
			/* client secret */, "MY_CLIENT_SECRET"
			/* callback uri  */, "MY_CALLBACK_URL"
		),
		;
		private String authUri;
		private HttpMethod authPreferedMethod;
		private String tokenUri;
		private HttpMethod tokenPreferedMethod;
		private String resourceServerUrl;
		private HttpMethod resourceServerPreferedMethod;
		private String[] resourceHeaderKey;
		private String[] resourceHeaderValue;
		private String clientId;
		private String clientSecret;
		private String callbackUri;
		public String getAuthUri() { return this.authUri; }
		public HttpMethod getAuthPreferedMethod() { return this.authPreferedMethod; }
		public String getTokenUri() { return this.tokenUri; }
		public HttpMethod getTokenPreferedMethod() { return this.tokenPreferedMethod; }
		public String getResourceServerUrl() { return this.resourceServerUrl; }
		public HttpMethod getResourceServerPreferedMethod() { return this.resourceServerPreferedMethod; }
		public String[] getResourceHeaderKeys() { return this.resourceHeaderKey; }
		public String[] getResourceHeaderValues() { return this.resourceHeaderValue; }
		public String getClientId() {return this.clientId; }
		public String getClientSecret() { return this.clientSecret; }
		public String getCallbackUri() { return this.callbackUri; }
		@Override
		public String toString() { return "DO NOT USE DEFAULT TOSTRING"; }
		private OAUTH2_CLIENT(
				String authUri
				, HttpMethod authPreferedMethod
				, String tokenUri
				, HttpMethod tokenPreferedMethod
				, String resourceServerUrl
				, HttpMethod resourceServerPreferedMethod
				, String[] resourceHeaderKey
				, String[] resourceHeaderValue
				, String clientId
				, String clientSecret
				, String callbackUri
		) {
			this.authUri = authUri;
			this.authPreferedMethod = authPreferedMethod;

			this.tokenUri = tokenUri;
			this.tokenPreferedMethod = tokenPreferedMethod;

			this.resourceServerUrl = resourceServerUrl;
			this.resourceServerPreferedMethod = resourceServerPreferedMethod;
			this.resourceHeaderKey = resourceHeaderKey;
			this.resourceHeaderValue = resourceHeaderValue;

			this.clientId = clientId;
			this.clientSecret = clientSecret;
			this.callbackUri = callbackUri;
		}
	}//END OF ENUM
}//END OF CLASS
```

### 인증과 인가를 거쳐 `Access Token` 발급을 위한 `TestAuthFacebookController` class

``` java
package controller;

import java.io.UnsupportedEncodingException;
import java.math.BigInteger;
import java.net.URLEncoder;
import java.nio.charset.Charset;
import java.security.SecureRandom;
import java.util.Map;

import javax.servlet.http.HttpServletResponse;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestMethod;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.servlet.ModelAndView;

import com.fasterxml.jackson.databind.ObjectMapper;

import util.Constants.OAUTH2_CLIENT;
import util.HttpUtils;

@Controller
public class TestAuthFacebookController {

	private static final Logger logger = LoggerFactory.getLogger(TestAuthFacebookController.class);
	public static String storedState = "";

	@RequestMapping(value="oauth/facebook/init", method=RequestMethod.GET)
	public ModelAndView oAuth2TestFacebookInit(HttpServletResponse httpServletResponse) throws UnsupportedEncodingException {
	    String stateToken = new BigInteger(130, new SecureRandom()).toString(32);
	    logger.debug("stateToken : " + stateToken);
	    TestAuthFacebookController.storedState = stateToken;
	    String redirectUrl = OAUTH2_CLIENT.FACEBOOK.getAuthUri()
	    		+ "?client_id=" + OAUTH2_CLIENT.FACEBOOK.getClientId()
	    		+ "&response_type=code"
	    		+ "&redirect_uri=" + URLEncoder.encode(OAUTH2_CLIENT.FACEBOOK.getCallbackUri(), Charset.forName("UTF-8").toString())
	    		+ "&state=" + stateToken
	    		+ "&scope=public_profile email manage_pages";
	    return new ModelAndView("redirect:" + redirectUrl);
	}//END OF FUNCTION

	@RequestMapping(value="oauth/facebook/callback", method=RequestMethod.GET)
	public String oAuth2TestFacebookCallback(@RequestParam Map<String,Object> map) throws Exception {
		String recvState = (String) map.get("state");
		logger.debug("recv state : " + recvState);
		String recvCode = (String) map.get("code");
		logger.debug("oAuth2TestFacebookCallback recv code : " + recvCode);
		if(TestAuthFacebookController.storedState.equals(recvState)) {
			String paramStr = ""
				+ "client_id=" + OAUTH2_CLIENT.FACEBOOK.getClientId()
				+ "&client_secret=" + OAUTH2_CLIENT.FACEBOOK.getClientSecret()
				+ "&code=" + recvCode
				+ "&redirect_uri=" + OAUTH2_CLIENT.FACEBOOK.getCallbackUri();

			ObjectMapper mapper = new ObjectMapper();
			String jsonInString = HttpUtils.sendAndRecv(
				OAUTH2_CLIENT.FACEBOOK.getTokenUri()
				, OAUTH2_CLIENT.FACEBOOK.getTokenPreferedMethod()
				, paramStr
			);

			logger.debug("AuthorizationServer recv : " + jsonInString);

		} else {
			throw new Exception("");
			//401 unauthorized
		}
		return "main";
	}//END OF FUNCTION

}//END OF CLASS

```
참고
- [Naver - OAuth와 춤을](https://d2.naver.com/helloworld/24942)
